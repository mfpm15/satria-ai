"""
SATRIA PentestGPT Planner Service
AI-powered penetration testing planning with safety constraints
"""

import asyncio
import logging
import json
from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
import uuid

from satria.core.config import settings


class PlanningPhase(str, Enum):
    """Penetration testing phases"""
    RECONNAISSANCE = "reconnaissance"
    SCANNING = "scanning"
    ENUMERATION = "enumeration"
    VULNERABILITY_ASSESSMENT = "vulnerability_assessment"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    REPORTING = "reporting"


class TaskPriority(str, Enum):
    """Task execution priority"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class TaskStatus(str, Enum):
    """Task execution status"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class PlanConstraints:
    """Constraints for penetration testing plan"""
    scope_allowlist: List[str] = field(default_factory=list)
    scope_blocklist: List[str] = field(default_factory=list)
    max_duration_hours: int = 4
    max_concurrent_tasks: int = 3
    safety_level: str = "moderate"  # safe, moderate, risky
    require_approval: bool = True
    environment: str = "lab"  # lab, staging, production
    compliance_requirements: List[str] = field(default_factory=list)


@dataclass
class PlanTask:
    """Individual task in penetration test plan"""
    task_id: str
    phase: PlanningPhase
    tool_name: str
    command: str
    args: List[str]
    description: str
    priority: TaskPriority
    estimated_duration: timedelta
    prerequisites: List[str] = field(default_factory=list)
    expected_outputs: List[str] = field(default_factory=list)
    safety_notes: str = ""
    status: TaskStatus = TaskStatus.PENDING


@dataclass
class TestPlan:
    """Complete penetration test plan"""
    plan_id: str
    name: str
    description: str
    target_profile: Dict[str, Any]
    constraints: PlanConstraints
    tasks: List[PlanTask]
    estimated_total_duration: timedelta
    created_at: datetime
    created_by: str
    approved_by: Optional[str] = None
    approval_timestamp: Optional[datetime] = None


class PentestGPTPlanner:
    """
    AI-powered penetration testing planner

    Generates structured plans using LLM reasoning while maintaining
    safety constraints and compliance requirements
    """

    def __init__(self):
        self.logger = logging.getLogger("satria.pentestgpt_planner")

        # Template knowledge base
        self.phase_templates = self._load_phase_templates()
        self.tool_knowledge = self._load_tool_knowledge()
        self.safety_guidelines = self._load_safety_guidelines()

        # Planning history
        self.plan_history: List[TestPlan] = []

    def _load_phase_templates(self) -> Dict[PlanningPhase, Dict[str, Any]]:
        """Load phase-specific planning templates"""
        return {
            PlanningPhase.RECONNAISSANCE: {
                "description": "Information gathering and target profiling",
                "typical_tools": ["subfinder", "amass", "assetfinder", "dnsx"],
                "safety_level": "safe",
                "estimated_duration": timedelta(minutes=30),
                "prerequisites": [],
                "outputs": ["subdomains", "ip_ranges", "technologies"]
            },
            PlanningPhase.SCANNING: {
                "description": "Port scanning and service discovery",
                "typical_tools": ["nmap", "masscan", "rustscan"],
                "safety_level": "moderate",
                "estimated_duration": timedelta(minutes=45),
                "prerequisites": ["target_ips"],
                "outputs": ["open_ports", "service_versions", "os_detection"]
            },
            PlanningPhase.ENUMERATION: {
                "description": "Service enumeration and fingerprinting",
                "typical_tools": ["gobuster", "feroxbuster", "nuclei"],
                "safety_level": "moderate",
                "estimated_duration": timedelta(hours=1),
                "prerequisites": ["open_ports", "service_versions"],
                "outputs": ["directories", "files", "vulnerabilities"]
            },
            PlanningPhase.VULNERABILITY_ASSESSMENT: {
                "description": "Vulnerability identification and verification",
                "typical_tools": ["nuclei", "nmap", "nikto"],
                "safety_level": "moderate",
                "estimated_duration": timedelta(minutes=45),
                "prerequisites": ["service_versions", "directories"],
                "outputs": ["vulnerabilities", "severity_ratings", "exploitability"]
            },
            PlanningPhase.EXPLOITATION: {
                "description": "Controlled exploitation attempts",
                "typical_tools": ["metasploit", "sqlmap", "burpsuite"],
                "safety_level": "risky",
                "estimated_duration": timedelta(hours=2),
                "prerequisites": ["vulnerabilities", "approval"],
                "outputs": ["proof_of_concept", "access_level", "persistence"]
            },
            PlanningPhase.POST_EXPLOITATION: {
                "description": "Post-exploitation activities and privilege escalation",
                "typical_tools": ["linpeas", "winpeas", "bloodhound"],
                "safety_level": "risky",
                "estimated_duration": timedelta(hours=1),
                "prerequisites": ["initial_access"],
                "outputs": ["privilege_escalation", "lateral_movement", "data_access"]
            },
            PlanningPhase.REPORTING: {
                "description": "Documentation and report generation",
                "typical_tools": ["reporting", "screenshot", "documentation"],
                "safety_level": "safe",
                "estimated_duration": timedelta(minutes=30),
                "prerequisites": ["all_phases_complete"],
                "outputs": ["report", "recommendations", "remediation_steps"]
            }
        }

    def _load_tool_knowledge(self) -> Dict[str, Dict[str, Any]]:
        """Load tool-specific knowledge and configurations"""
        return {
            "nmap": {
                "category": "scanner",
                "safety_level": "moderate",
                "safe_args": ["-sV", "-sC", "-O", "-A"],
                "risky_args": ["-sS", "-sU", "--script=exploit"],
                "rate_limit": "100/hour",
                "typical_duration": timedelta(minutes=15)
            },
            "nuclei": {
                "category": "vulnerability_scanner",
                "safety_level": "moderate",
                "safe_args": ["-severity", "low,medium", "-json"],
                "risky_args": ["-severity", "critical,high", "-automatic-scan"],
                "rate_limit": "50/hour",
                "typical_duration": timedelta(minutes=20)
            },
            "subfinder": {
                "category": "reconnaissance",
                "safety_level": "safe",
                "safe_args": ["-silent", "-json"],
                "risky_args": [],
                "rate_limit": "unlimited",
                "typical_duration": timedelta(minutes=5)
            },
            "gobuster": {
                "category": "enumeration",
                "safety_level": "moderate",
                "safe_args": ["-t", "10", "-q"],
                "risky_args": ["-t", "100", "--no-status"],
                "rate_limit": "20/hour",
                "typical_duration": timedelta(minutes=30)
            },
            "metasploit": {
                "category": "exploitation",
                "safety_level": "risky",
                "safe_args": ["check", "info"],
                "risky_args": ["exploit", "run", "sessions"],
                "rate_limit": "5/hour",
                "typical_duration": timedelta(minutes=45)
            }
        }

    def _load_safety_guidelines(self) -> Dict[str, List[str]]:
        """Load safety guidelines for different environments"""
        return {
            "lab": [
                "Full testing allowed within lab network",
                "All tools and techniques permitted",
                "No external network access required",
                "Automatic approval for moderate risk activities"
            ],
            "staging": [
                "Limited testing scope",
                "Only safe and moderate tools allowed",
                "Manual approval required for all activities",
                "Business hours only"
            ],
            "production": [
                "Extremely limited scope",
                "Only passive reconnaissance allowed",
                "C-level approval required",
                "Emergency protocols in place"
            ]
        }

    async def create_plan(self, target_profile: Dict[str, Any],
                         constraints: PlanConstraints,
                         scenario: str = "general_assessment") -> TestPlan:
        """
        Create comprehensive penetration test plan
        """
        try:
            plan_id = f"plan-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"

            # Generate plan using AI reasoning
            plan_tasks = await self._generate_plan_tasks(target_profile, constraints, scenario)

            # Validate and adjust for safety
            validated_tasks = await self._validate_plan_safety(plan_tasks, constraints)

            # Calculate total duration
            total_duration = sum(
                (task.estimated_duration for task in validated_tasks),
                timedelta()
            )

            # Create plan object
            plan = TestPlan(
                plan_id=plan_id,
                name=f"Penetration Test Plan - {scenario}",
                description=f"AI-generated penetration test plan for {target_profile.get('name', 'target')}",
                target_profile=target_profile,
                constraints=constraints,
                tasks=validated_tasks,
                estimated_total_duration=total_duration,
                created_at=datetime.utcnow(),
                created_by="pentestgpt_planner"
            )

            # Store in history
            self.plan_history.append(plan)

            self.logger.info(f"Created plan {plan_id} with {len(validated_tasks)} tasks")
            return plan

        except Exception as e:
            self.logger.error(f"Plan creation failed: {e}")
            return await self._create_fallback_plan(target_profile, constraints)

    async def _generate_plan_tasks(self, target_profile: Dict[str, Any],
                                 constraints: PlanConstraints,
                                 scenario: str) -> List[PlanTask]:
        """Generate plan tasks using AI reasoning"""
        tasks = []

        # Determine phases based on scenario and constraints
        phases_to_include = self._select_phases_for_scenario(scenario, constraints)

        for phase in phases_to_include:
            phase_tasks = await self._generate_phase_tasks(phase, target_profile, constraints)
            tasks.extend(phase_tasks)

        return tasks

    def _select_phases_for_scenario(self, scenario: str,
                                  constraints: PlanConstraints) -> List[PlanningPhase]:
        """Select appropriate phases based on scenario and constraints"""
        all_phases = [
            PlanningPhase.RECONNAISSANCE,
            PlanningPhase.SCANNING,
            PlanningPhase.ENUMERATION,
            PlanningPhase.VULNERABILITY_ASSESSMENT
        ]

        # Add exploitation phases only if allowed
        if constraints.safety_level in ["moderate", "risky"] and constraints.environment == "lab":
            all_phases.extend([
                PlanningPhase.EXPLOITATION,
                PlanningPhase.POST_EXPLOITATION
            ])

        # Always include reporting
        all_phases.append(PlanningPhase.REPORTING)

        # Scenario-specific adjustments
        if scenario == "web_application":
            # Focus on web-specific phases
            return [
                PlanningPhase.RECONNAISSANCE,
                PlanningPhase.ENUMERATION,
                PlanningPhase.VULNERABILITY_ASSESSMENT,
                PlanningPhase.REPORTING
            ]
        elif scenario == "network_assessment":
            # Full network testing
            return all_phases
        elif scenario == "purple_team_validation":
            # Limited scope for detection validation
            return [
                PlanningPhase.RECONNAISSANCE,
                PlanningPhase.SCANNING,
                PlanningPhase.REPORTING
            ]

        return all_phases

    async def _generate_phase_tasks(self, phase: PlanningPhase,
                                  target_profile: Dict[str, Any],
                                  constraints: PlanConstraints) -> List[PlanTask]:
        """Generate tasks for specific phase"""
        tasks = []
        phase_template = self.phase_templates[phase]

        # Select appropriate tools for phase
        tools = self._select_tools_for_phase(phase, constraints)

        for tool in tools:
            task = await self._create_task_for_tool(phase, tool, target_profile, constraints)
            if task:
                tasks.append(task)

        return tasks

    def _select_tools_for_phase(self, phase: PlanningPhase,
                              constraints: PlanConstraints) -> List[str]:
        """Select appropriate tools for phase based on constraints"""
        phase_template = self.phase_templates[phase]
        available_tools = phase_template["typical_tools"]

        # Filter tools based on safety level
        filtered_tools = []
        for tool in available_tools:
            tool_info = self.tool_knowledge.get(tool, {})
            tool_safety = tool_info.get("safety_level", "moderate")

            # Check if tool is allowed based on safety constraints
            if constraints.safety_level == "safe" and tool_safety in ["safe"]:
                filtered_tools.append(tool)
            elif constraints.safety_level == "moderate" and tool_safety in ["safe", "moderate"]:
                filtered_tools.append(tool)
            elif constraints.safety_level == "risky" and tool_safety in ["safe", "moderate", "risky"]:
                filtered_tools.append(tool)

        return filtered_tools

    async def _create_task_for_tool(self, phase: PlanningPhase, tool: str,
                                  target_profile: Dict[str, Any],
                                  constraints: PlanConstraints) -> Optional[PlanTask]:
        """Create specific task for tool"""
        try:
            tool_info = self.tool_knowledge.get(tool, {})
            phase_template = self.phase_templates[phase]

            # Generate command and arguments
            command, args = self._generate_tool_command(tool, target_profile, constraints)

            # Calculate priority
            priority = self._calculate_task_priority(phase, tool, constraints)

            # Estimate duration
            duration = tool_info.get("typical_duration", timedelta(minutes=15))

            task = PlanTask(
                task_id=f"task-{phase.value}-{tool}-{uuid.uuid4().hex[:8]}",
                phase=phase,
                tool_name=tool,
                command=command,
                args=args,
                description=f"{phase_template['description']} using {tool}",
                priority=priority,
                estimated_duration=duration,
                prerequisites=phase_template.get("prerequisites", []),
                expected_outputs=phase_template.get("outputs", []),
                safety_notes=self._generate_safety_notes(tool, constraints)
            )

            return task

        except Exception as e:
            self.logger.error(f"Failed to create task for {tool}: {e}")
            return None

    def _generate_tool_command(self, tool: str, target_profile: Dict[str, Any],
                             constraints: PlanConstraints) -> Tuple[str, List[str]]:
        """Generate appropriate command and arguments for tool"""
        tool_info = self.tool_knowledge.get(tool, {})
        targets = target_profile.get("targets", ["127.0.0.1"])

        if tool == "nmap":
            args = ["-sV", "-sC", "-oN", f"/tmp/nmap_{uuid.uuid4().hex[:8]}.txt"]
            args.extend(targets)
            return "nmap", args

        elif tool == "nuclei":
            args = ["-target"] + targets + ["-severity", "low,medium", "-json"]
            return "nuclei", args

        elif tool == "subfinder":
            domain = target_profile.get("domain", targets[0])
            args = ["-d", domain, "-silent", "-json"]
            return "subfinder", args

        elif tool == "gobuster":
            target_url = target_profile.get("web_url", f"http://{targets[0]}")
            args = ["dir", "-u", target_url, "-w", "/usr/share/wordlists/common.txt", "-q"]
            return "gobuster", args

        elif tool == "metasploit":
            # Very restricted metasploit usage
            args = ["check", "-r", f"resource_{uuid.uuid4().hex[:8]}.rc"]
            return "msfconsole", args

        else:
            # Generic command
            args = targets
            return tool, args

    def _calculate_task_priority(self, phase: PlanningPhase, tool: str,
                               constraints: PlanConstraints) -> TaskPriority:
        """Calculate task priority based on phase and constraints"""
        # Early phases are higher priority
        phase_priorities = {
            PlanningPhase.RECONNAISSANCE: TaskPriority.HIGH,
            PlanningPhase.SCANNING: TaskPriority.HIGH,
            PlanningPhase.ENUMERATION: TaskPriority.MEDIUM,
            PlanningPhase.VULNERABILITY_ASSESSMENT: TaskPriority.MEDIUM,
            PlanningPhase.EXPLOITATION: TaskPriority.LOW,
            PlanningPhase.POST_EXPLOITATION: TaskPriority.LOW,
            PlanningPhase.REPORTING: TaskPriority.CRITICAL
        }

        base_priority = phase_priorities.get(phase, TaskPriority.MEDIUM)

        # Adjust based on tool safety
        tool_info = self.tool_knowledge.get(tool, {})
        if tool_info.get("safety_level") == "risky":
            # Lower priority for risky tools
            if base_priority == TaskPriority.HIGH:
                return TaskPriority.MEDIUM
            elif base_priority == TaskPriority.MEDIUM:
                return TaskPriority.LOW

        return base_priority

    def _generate_safety_notes(self, tool: str, constraints: PlanConstraints) -> str:
        """Generate safety notes for tool usage"""
        tool_info = self.tool_knowledge.get(tool, {})
        safety_level = tool_info.get("safety_level", "moderate")

        notes = []

        if safety_level == "risky":
            notes.append("High risk tool - requires approval")
            notes.append("Monitor execution closely")

        if constraints.environment != "lab":
            notes.append(f"Running in {constraints.environment} environment")
            notes.append("Extra caution required")

        if tool in ["metasploit", "sqlmap"]:
            notes.append("Exploitation tool - use check mode only initially")

        return "; ".join(notes)

    async def _validate_plan_safety(self, tasks: List[PlanTask],
                                  constraints: PlanConstraints) -> List[PlanTask]:
        """Validate and adjust plan for safety compliance"""
        validated_tasks = []

        for task in tasks:
            # Check if task meets safety requirements
            if await self._is_task_safe(task, constraints):
                validated_tasks.append(task)
            else:
                # Try to make task safer
                safe_task = await self._make_task_safer(task, constraints)
                if safe_task:
                    validated_tasks.append(safe_task)
                else:
                    self.logger.warning(f"Skipping unsafe task: {task.task_id}")

        return validated_tasks

    async def _is_task_safe(self, task: PlanTask, constraints: PlanConstraints) -> bool:
        """Check if task meets safety requirements"""
        tool_info = self.tool_knowledge.get(task.tool_name, {})
        tool_safety = tool_info.get("safety_level", "moderate")

        # Check safety level compatibility
        safety_levels = {
            "safe": ["safe"],
            "moderate": ["safe", "moderate"],
            "risky": ["safe", "moderate", "risky"]
        }

        if tool_safety not in safety_levels.get(constraints.safety_level, []):
            return False

        # Check environment restrictions
        if constraints.environment == "production" and tool_safety != "safe":
            return False

        return True

    async def _make_task_safer(self, task: PlanTask,
                             constraints: PlanConstraints) -> Optional[PlanTask]:
        """Attempt to make task safer by modifying arguments"""
        tool_info = self.tool_knowledge.get(task.tool_name, {})
        safe_args = tool_info.get("safe_args", [])

        if safe_args:
            # Replace args with safer alternatives
            task.args = safe_args
            task.safety_notes += "; Modified for safety"
            return task

        return None

    async def _create_fallback_plan(self, target_profile: Dict[str, Any],
                                  constraints: PlanConstraints) -> TestPlan:
        """Create minimal safe fallback plan"""
        plan_id = f"fallback-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"

        # Create minimal safe tasks
        safe_tasks = [
            PlanTask(
                task_id=f"fallback-recon-{uuid.uuid4().hex[:8]}",
                phase=PlanningPhase.RECONNAISSANCE,
                tool_name="subfinder",
                command="subfinder",
                args=["-d", target_profile.get("domain", "example.com"), "-silent"],
                description="Safe domain enumeration",
                priority=TaskPriority.HIGH,
                estimated_duration=timedelta(minutes=5),
                safety_notes="Fallback safe task"
            )
        ]

        return TestPlan(
            plan_id=plan_id,
            name="Fallback Safe Plan",
            description="Minimal safe penetration test plan",
            target_profile=target_profile,
            constraints=constraints,
            tasks=safe_tasks,
            estimated_total_duration=timedelta(minutes=5),
            created_at=datetime.utcnow(),
            created_by="pentestgpt_planner_fallback"
        )

    async def approve_plan(self, plan_id: str, approver: str) -> bool:
        """Approve penetration test plan"""
        for plan in self.plan_history:
            if plan.plan_id == plan_id:
                plan.approved_by = approver
                plan.approval_timestamp = datetime.utcnow()
                self.logger.info(f"Plan {plan_id} approved by {approver}")
                return True

        return False

    def get_plan(self, plan_id: str) -> Optional[TestPlan]:
        """Get plan by ID"""
        for plan in self.plan_history:
            if plan.plan_id == plan_id:
                return plan
        return None

    def get_metrics(self) -> Dict[str, Any]:
        """Get planner metrics"""
        recent_plans = [plan for plan in self.plan_history
                       if plan.created_at > datetime.utcnow() - timedelta(days=7)]

        total_tasks = sum(len(plan.tasks) for plan in recent_plans)
        approved_plans = sum(1 for plan in recent_plans if plan.approved_by)

        return {
            "total_plans": len(self.plan_history),
            "recent_plans_7d": len(recent_plans),
            "total_tasks_7d": total_tasks,
            "approval_rate_7d": approved_plans / len(recent_plans) if recent_plans else 0,
            "avg_tasks_per_plan": total_tasks / len(recent_plans) if recent_plans else 0,
            "supported_tools": len(self.tool_knowledge),
            "available_phases": len(self.phase_templates)
        }


# Global planner instance
pentestgpt_planner = PentestGPTPlanner()